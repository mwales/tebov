#!/usr/bin/env python3

import sys
#import crypt
import binascii
import struct
import bz2
import re
import paramiko
import logging
import stat

from common_backup_utils import ConfigFile, BackupUtils, CryptoUtils, RemoteServer

def password_double_prompt():
    print("Enter password:")
    password = input()
    print("Enter password again:")
    password2 = input()
    if password != password2:
        print("Passwords don't match")
        return None
    return password


def encrypt_tool(in_path, out_path):
    ptf = open(in_path, "rb")
    ctf = open(out_path, "wb")

    password = password_double_prompt()
    if not password:
        return

    key = CryptoUtils.deriveKey(password)

    while True:
        pt_data = ptf.read(CryptoUtils.chunkSize)

        if len(pt_data) == 0:
            break

        ct_data = CryptoUtils.encryptBytes(key, pt_data)
        print(f"Encrypting a chunk of size {len(pt_data)} down to {len(ct_data)}")

        len_chunk_data = struct.pack(">I", len(ct_data))

        ctf.write(len_chunk_data)
        ctf.write(ct_data)

    ptf.close()
    ctf.close()

def decrypt_tool(in_path, out_path):
    ctf = open(in_path, "rb")
    ptf = open(out_path, "wb")

    print("Enter password:")
    password = input()
    key = CryptoUtils.deriveKey(password)

    while True:
        len_chunk_data_bytes = ctf.read(4)
        if len(len_chunk_data_bytes) != 4:
            break
        len_chunk_data = struct.unpack(">I", len_chunk_data_bytes)[0]
        print(f"Decrypted chunk = {len_chunk_data}")

        ct_data = ctf.read(len_chunk_data)
        
        pt_data = CryptoUtils.decryptBytes(key, ct_data)

        ptf.write(pt_data)

        if len(pt_data) == 0:
            break

    ptf.close()
    ctf.close()

def compress_tool(in_path, out_path):
    in_file = open(in_path, "rb")
    out_file = open(out_path, "wb")
    
    compressor = bz2.BZ2Compressor()

    chunk_size = 16 * 1024 * 1024

    br = [ 0 ]
    uncompress_size = 0
    compress_size = 0
    while len(br) > 0:
        br = in_file.read(chunk_size)
        uncompress_size += len(br)

        bc = compressor.compress(br)
        compress_size += len(bc)
        out_file.write(bc)

    bc = compressor.flush()
    compress_size += len(bc)

    out_file.write(bc)
    in_file.close()
    out_file.close()
    print(f"Compressed {in_path} from {uncompress_size} down to {compress_size} in {out_path}")


def decompress_tool(in_path, out_path):
    in_file = open(in_path, "rb")
    out_file = open(out_path, "wb")
    
    decompressor = bz2.BZ2Decompressor()

    chunk_size = 16 * 1024 * 1024

    br = [ 0 ]
    compress_size = 0
    uncompress_size = 0
    while len(br) > 0:
        br = in_file.read(chunk_size)
        compress_size += len(br)

        if len(br) <= 0:
            break

        bc = decompressor.decompress(br)
        uncompress_size += len(bc)
        out_file.write(bc)

    in_file.close()
    out_file.close()
    print(f"Decompressed {in_path} from {compress_size} up to {uncompress_size} in {out_path}")

def parse_remote(s: str):
    """ Returns a tuple that is ( user, host, path ) """
    REMOTE_RE = re.compile(r'^([^@]+)@([^:]+):(.+)$')
    m = REMOTE_RE.match(s)
    if not m:
        raise ValueError(f"Invalid remote path: {s!r}")

    return ( m.group(1), m.group(2), m.group(3) )

def compress_crypt_send(in_file, out_file):

    password = password_double_prompt()
    if not password:
        return

    username, hostname, path = parse_remote(out_file)

    key = CryptoUtils.deriveKey(password)

    rs = RemoteServer(hostname, username, path)

    hashdigest, br, bw = rs.compress_crypt_txfer(key, in_file)

    rs.close()

    print(f"Compressed {br} bytes down into {bw}, encrypted file hash = {hashdigest.hex()}")

def verify_file_backed_up(in_file, out_file):
    print("Enter password:")
    password = input()
 
    key = CryptoUtils.deriveKey(password)
    hash_val, file_len = CryptoUtils.compute_compress_crypt_hash(in_file, key)
    
    username, hostname, path = parse_remote(out_file)

    folder, filename = RemoteServer.hash_to_filepath(hash_val)

    rs = RemoteServer(hostname, username, path)

    remote_size = rs.get_remote_file_size(folder + "/" + filename)
   
    rs.close()

    if remote_size != 0 and remote_size == file_len:
        print(f"Local file {in_file} exists as {folder}/{filename} on remote system")
    else:
        print(f"Local file {in_file} is NOT on remote system")
        print(f"Should exist at {folder}/{filename}")

def print_usage(self_name, tool_list):
    print(f"Usage {self_name} tool infile outfile")

    for tool, _, tool_help in tool_list:
        print(f"    {tool}: {tool_help}")
    print("")
 



def main(args):
    logging.basicConfig(level=logging.DEBUG)

    tool_list = [ ( "encrypt", encrypt_tool, "Encrypt a file using AES-SIV" ),
                  ( "decrypt", decrypt_tool, "Decrypt a file using AES-SIV" ),
                  ( "compress", compress_tool, "Compress a file using bzip compression" ),
                  ( "decompress", decompress_tool, "Decompress a file using bzip compression"),
                  ( "compress_crypt_send", compress_crypt_send, "Compress, crypt, and send" ),
                  ( "verify_file_backed_up", verify_file_backed_up, "Verify the presence of backup file on server") ] 


    if len(args) != 4:
        print_usage(sys.argv[0], tool_list)
        return

    tool_name = args[1]
    in_path = args[2]
    out_path = args[3]


    for tool, tool_func, _ in tool_list:
        if tool == tool_name:
            tool_func(in_path, out_path)
            return 0
    else:
        print_usage(sys.argv[0], tool_list)
       

if __name__ == "__main__":
    main(sys.argv)
