#!/usr/bin/env python3

# For Ubuntu, we need the following packages installed
# python3-argcomplete python3-paramiko

import sys
#import crypt
import binascii
import struct
import bz2
import re
import paramiko
import logging
import stat
import os
import argparse
import getpass

import argcomplete 
import paramiko

from common_backup_utils import ConfigFile, BackupUtils, CryptoUtils, RemoteServer


def password_double_prompt():
    print("Enter password:")
    password = getpass.getpass()
    print("Enter password again:")
    password2 = getpass.getpass()
    if password != password2:
        print("Passwords don't match")
        return None
    return password


def encrypt_mode(args):
    ptf = args.pt_path
    ctf = args.ct_path

    if args.password:
        password = args.password
    else:
        password = password_double_prompt()

    if not password:
        sys.stderr.write("Error with password\n")
        return

    key = CryptoUtils.deriveKey(password)

    while True:
        pt_data = ptf.read(CryptoUtils.chunkSize)

        if len(pt_data) == 0:
            break

        ct_data = CryptoUtils.encryptBytes(key, pt_data)
        print(f"Encrypting a chunk of size {len(pt_data)} down to {len(ct_data)}")

        len_chunk_data = struct.pack(">I", len(ct_data))

        ctf.write(len_chunk_data)
        ctf.write(ct_data)

    ptf.close()
    ctf.close()

def decrypt_mode(args):
    ctf = args.ct_path
    ptf = args.pt_path

    if args.password:
        password = args.password
    else:
        print("Enter password:")
        password = getpass.getpass

    key = CryptoUtils.deriveKey(password)

    while True:
        len_chunk_data_bytes = ctf.read(4)
        if len(len_chunk_data_bytes) != 4:
            break
        len_chunk_data = struct.unpack(">I", len_chunk_data_bytes)[0]
        print(f"Decrypted chunk = {len_chunk_data}")

        ct_data = ctf.read(len_chunk_data)
        
        pt_data = CryptoUtils.decryptBytes(key, ct_data)

        ptf.write(pt_data)

        if len(pt_data) == 0:
            break

    ptf.close()
    ctf.close()

def compress_mode(args):
    in_file = args.in_path
    out_file = args.out_path

    compressor = bz2.BZ2Compressor()

    chunk_size = 16 * 1024 * 1024

    br = [ 0 ]
    uncompress_size = 0
    compress_size = 0
    while len(br) > 0:
        br = in_file.read(chunk_size)
        uncompress_size += len(br)

        bc = compressor.compress(br)
        compress_size += len(bc)
        out_file.write(bc)

    bc = compressor.flush()
    compress_size += len(bc)

    out_file.write(bc)
    in_file.close()
    out_file.close()
    print(f"Compressed {in_file.name} from {uncompress_size} down to {compress_size} in {out_file.name}")

def decompress_mode(args):
    in_file = args.in_path
    out_file = args.out_path
   
    decompressor = bz2.BZ2Decompressor()

    chunk_size = 16 * 1024 * 1024

    br = [ 0 ]
    compress_size = 0
    uncompress_size = 0
    while len(br) > 0:
        br = in_file.read(chunk_size)
        compress_size += len(br)

        if len(br) <= 0:
            break

        bc = decompressor.decompress(br)
        uncompress_size += len(bc)
        out_file.write(bc)

    in_file.close()
    out_file.close()
    print(f"Decompressed {in_file.name} from {compress_size} up to {uncompress_size} in {out_file.name}")

def parse_remote(s: str):
    """ Returns a tuple that is ( user, host, path ) """
    REMOTE_RE = re.compile(r'^([^@]+)@([^:]+):(.+)$')
    m = REMOTE_RE.match(s)
    if not m:
        raise ValueError(f"Invalid remote path: {s!r}")

    return ( m.group(1), m.group(2), m.group(3) )

def backup_file_mode(args):

    if args.password:
        password = args.password
    else:
        password = password_double_prompt()

    if not password:
        sys.stderr.write("Error with password\n")
        return

    username, hostname, path = parse_remote(args.dest_scp_folder)

    key = CryptoUtils.deriveKey(password)

    rs = RemoteServer(hostname, username, path)

    hashdigest, br, bw = rs.compress_crypt_txfer(key, args.in_file)

    rs.close()

    print(f"Compressed {br} bytes down into {bw}, encrypted file hash = {hashdigest.hex()}")

def verify_single_file_mode(args):
    if args.password:
        password = args.password
    else:
        print("Enter password:")
        password = getpass.getpass
 
    key = CryptoUtils.deriveKey(password)
    hash_val, file_len = CryptoUtils.compute_compress_crypt_hash(args.in_file, key)
    
    username, hostname, path = parse_remote(args.dest_scp_folder)

    folder, filename = RemoteServer.hash_to_filepath(hash_val)

    rs = RemoteServer(hostname, username, path)

    remote_size = rs.get_remote_file_size(folder + "/" + filename)
   
    rs.close()

    if remote_size != 0 and remote_size == file_len:
        print(f"Local file {in_file} exists as {folder}/{filename} on remote system")
    else:
        print(f"Local file {in_file} is NOT on remote system")
        print(f"Should exist at {folder}/{filename}")


def verify_manifest_mode(args):
    manifest_file = args.manifest
    logging.debug(f"Path to backup data = {args.backup_folder}")
    num_entries_len = struct.calcsize(">II")
    num_entries_bytes = manifest_file.read(num_entries_len)
    num_entries, num_zero_len = struct.unpack(">II", num_entries_bytes)

    passed_verification = 0
    failed_verification = 0
    for i in range(num_entries - num_zero_len):
        hash_bytes = manifest_file.read(CryptoUtils.hash_size)
        if len(hash_bytes) != CryptoUtils.hash_size:
            failed_verification += 1
            print(f"Missing hash for file {i}")
            continue

        folders, filename = RemoteServer.hash_to_filepath(hash_bytes)
        full_file_path = os.path.join(args.backup_folder, folders, filename)
        logging.debug(f"Need to verify contents of {full_file_path}")

        try:
            file_hash, file_len = CryptoUtils.calc_local_file_hash(full_file_path)
        except Exception as e:
            logging.debug(f"Exception during hashing of {full_file_path}")
            failed_verification += 1
            continue

        if file_hash == hash_bytes:
            logging.debug(f"Verified contents of {full_file_path}")
            passed_verification +=1
        else:
            logging.debug(f"Verification failed of {full_file_path}")
            failed_verification += 1

    print(f"NUM_FILES={num_entries}")
    print(f"NUM_ZERO_LEN={num_zero_len}")
    print(f"PASSED={passed_verification}")
    print(f"FAILED={failed_verification}")



def main(args):
    logging.basicConfig(level=logging.DEBUG)

    tebov_parser = argparse.ArgumentParser(prog="tebov",
                                           description="Performs Trust-no-one Encrypted Backups Offsite with Verification")
    op_mode_parsers = tebov_parser.add_subparsers(dest="command", required=True, help="Mode of operation for tebov")

    encrypt_mode_parser = op_mode_parsers.add_parser("encrypt", help="Encrypts a single file")
    encrypt_mode_parser.add_argument("pt_path", type=argparse.FileType("rb"), help="path to plaintext file to be encrypted")
    encrypt_mode_parser.add_argument("ct_path", type=argparse.FileType("wb"), help="path to where ciphertext should be stored")
    encrypt_mode_parser.add_argument("--password", type=str, help="password for encryption (discouraged)")
    encrypt_mode_parser.set_defaults(func=encrypt_mode)
    
    decrypt_mode_parser = op_mode_parsers.add_parser("decrypt", help="Decrypts a single file")
    decrypt_mode_parser.add_argument("ct_path", type=argparse.FileType("rb"), help="path to ciphertext to be decrypted")
    decrypt_mode_parser.add_argument("pt_path", type=argparse.FileType("wb"), help="path to where plaintext should be stored")
    decrypt_mode_parser.add_argument("--password", type=str, help="password for decryption (discouraged)")
    decrypt_mode_parser.set_defaults(func=decrypt_mode)

    compress_mode_parser = op_mode_parsers.add_parser("compress", help="Compresses a single file")
    compress_mode_parser.add_argument("in_path", type=argparse.FileType("rb"), help="path to file to be compressed")
    compress_mode_parser.add_argument("out_path", type=argparse.FileType("wb"), help="path to where compressed file should be stored")
    compress_mode_parser.set_defaults(func=compress_mode)
 
    decompress_mode_parser = op_mode_parsers.add_parser("decompress", help="Decompresses a single file")
    decompress_mode_parser.add_argument("in_path", type=argparse.FileType("rb"), help="path to file to be decompressed")
    decompress_mode_parser.add_argument("out_path", type=argparse.FileType("wb"), help="path to where decompressed file should be stored")
    decompress_mode_parser.set_defaults(func=decompress_mode)
 
    backup_single_mode_parser = op_mode_parsers.add_parser("backup_file", help="Backups a single file by compressing, encrypting, and SFTPing.")
    backup_single_mode_parser.add_argument("in_file", type=str, help="path to plaintext file to be backed up")
    backup_single_mode_parser.add_argument("dest_scp_folder", type=str,
                                  help="Where to send the file (filename is generated). Ex: user@host:/path/to/folder")
    backup_single_mode_parser.add_argument("--password", type=str, help="password for encryption (discouraged)")
    backup_single_mode_parser.set_defaults(func=backup_file_mode)

    verify_file_mode_parser = op_mode_parsers.add_parser("verify_file", help="Verifies a single file has been backed up")
    verify_file_mode_parser.add_argument("in_file", type=str, help="path to plaintext file to be verified")
    verify_file_mode_parser.add_argument("dest_scp_folder", type=str, help="Folder where backups sent. Ex: user@host:/path/to/folder")
    verify_file_mode_parser.add_argument("--password", type=str, help="password for encryption (discouraged)")
    verify_file_mode_parser.set_defaults(func=verify_single_file_mode)

    verify_manifest_mode_parser = op_mode_parsers.add_parser("verify_manifest", help="Verifies a single manifest has been backed up (locally)")
    verify_manifest_mode_parser.add_argument("manifest", type=argparse.FileType("rb"), help="path to manifest file to be verified")
    verify_manifest_mode_parser.add_argument("backup_folder", type=str, help="Folder where backups stored (local path)")
    verify_manifest_mode_parser.set_defaults(func=verify_manifest_mode)
    

    argcomplete.autocomplete(tebov_parser)
    args = tebov_parser.parse_args()

    args.func(args)

      

if __name__ == "__main__":
    main(sys.argv)
